---
title: "create-prediction-grid"
output:
  pdf_document: default
  html_document: default
date: "2023-07-20"
---

Libraries

```{r, message=F}
#library(raster)   # -- old
#library(sp)       # -- old
#library(rgdal)    # -- deprecated in 10/2023
#library(rgeos)    # -- deprecated in 10/2023
#library(maptools) # -- deprecated in 10/2023
library(terra)
library(sf)

library(ggplot2)
library(ggspatial)
library(tidyterra)
library(rgeos)
library(data.table) # -- for large flat datasets
```

### In this script...

#### 1) Create empty grid

1.  Open NC borders and 30m-imperviousness data over NC

2.  Compute imperviousness mean over 5km-resolution grid

3.  Create an urban mask defined as 5kmx5km grid cells with imperviousness \>5%

4.  Create a grid with 1kmx1km cells above rural areas and 200mx200m cells above urban ones

#### 2) Add covariates

-   Land cover and urban indicators: imperviousness, building footprint, building height, tree canopy cover

-   Digital Elevation Model (DEM)

-   Meteorological covariates (pb evolves in time)

## Empty grid creation

### NC borders

```{r}
nc.borders <- vect("../input/NC_county_boundary/North_Carolina_State_and_County_Boundary_Polygons.shp")
```

Change nc.borders units (us feet to meter)

```{r}
crs.meters <- "+proj=lcc +lat_0=33.75 +lon_0=-79 +lat_1=36.1666666666667 +lat_2=34.3333333333333 +x_0=609601.219202439 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
nc.borders <- project(nc.borders, crs.meters)
```

### 5km-resolution imperviousness grid

Open and map imperviousness 30m-resolution data across NC

```{r}
imp <- rast("../input/NC_imperviousness_2019.tif")
imp <- project(imp, crs.meters)

imp.plot <- ifel(imp==0, NA, imp)
ggplot() +
  geom_spatraster(data = imp.plot) +
  geom_sf(data = st_as_sf(nc.borders), aes(geometry=geometry), 
               colour = "grey", linewidth=.3, fill = NA) +
  scale_fill_whitebox_c(
    palette = "muted",
    labels = scales::label_number(suffix = "%"),
    n.breaks = 12,
    guide = guide_legend(reverse = TRUE),
    na.value=NA
  ) +
  labs(
    fill = "",
    title = "Prediction grid"
  ) +
  annotation_scale(
    location="bl", pad_x = unit(1, "cm"), 
		pad_y = unit(1, "cm"), 
		height = unit(0.30, "cm"), 
		text_cex = 1
	) +
	annotation_north_arrow(
	  location = "br", 
	  which_north = "true", 
		pad_x = unit(0.2, "cm"), 
		pad_y = unit(0.2, "cm")
	) +
	theme(
			axis.text = element_text(size=12, family="serif"),
			plot.caption = element_text(size=10, family="serif"),
			legend.text = element_text(size=12, family="serif"),
			legend.title = element_text(size=12, family="serif"),
			panel.background = element_rect(fill = "white"),
			panel.grid.major=element_line(colour="grey")
		)
```

Create 5km and 10km-resolution raster in NC shapefile

```{r}
grid.10km <- rast(ext(nc.borders), resolution = c(10000, 10000), crs = crs.meters)
grid.10km <- extend(grid.10km, c(1,1))
grid.10km <- as.polygons(grid.10km)
grid.10km <- terra::intersect(grid.10km, nc.borders)
plot(grid.10km)

grid.5km <- rast(ext(nc.borders), resolution = c(5000,5000), crs = crs.meters)
grid.5km <- extend(grid.5km, c(1,1))
grid.5km <- as.polygons(grid.5km)
grid.5km <- terra::intersect(grid.5km, nc.borders)
plot(grid.5km)
```

Compute and save 5kmx5km imperviousness file (each 5kmx5km cell is the mean of 30mx30m info)

```{r, eval=F}
imp.mean <- zonal(imp, final.grid, fun='mean', as.raster=T)
writeRaster(imp.mean, filename="../input/NC_imperviousness_2019_5kmx5km.tif", overwrite=T)
```

Open and map the 5kmx5km imperviousness file

```{r}
imp.mean <- rast("../input/NC_imperviousness_2019_5kmx5km.tif")
ggplot() +
  geom_spatraster(data = imp.mean) +
  geom_sf(data = st_as_sf(nc.borders), aes(geometry=geometry), 
               colour = "white", linewidth=.3, fill = NA) +
  scale_fill_whitebox_c(
    palette = "muted",
    labels = scales::label_number(suffix = "%"),
    n.breaks = 12,
    guide = guide_legend(reverse = TRUE)
  ) +
  labs(
    fill = "",
    title = "North Carolina imperviousness rate"
  ) +
  annotation_scale(
    location="bl", pad_x = unit(1, "cm"), 
		pad_y = unit(1, "cm"), 
		height = unit(0.30, "cm"), 
		text_cex = 1
	) +
	annotation_north_arrow(
	  location = "br", 
	  which_north = "true", 
		pad_x = unit(0.2, "cm"), 
		pad_y = unit(0.2, "cm")
	) +
	theme(
			axis.text = element_text(size=12, family="serif"),
			plot.caption = element_text(size=10, family="serif"),
			legend.text = element_text(size=12, family="serif"),
			legend.title = element_text(size=12, family="serif"),
			panel.background = element_rect(fill = "white"),
			panel.grid.major=element_line(colour="grey")
		)
```

### Create urban and rural masks

-   Urban pixels: 5kmx5km imperviousness \> 5%

-   Urban pixels: 5kmx5km imperviousness \<= 5%

```{r}
urb.mask <- ifel(imp.mean>5, 1, NA)
rur.mask <- ifel(imp.mean<=5, 1,NA)
ggplot() +
  geom_spatraster(data = urb.mask) +
  geom_sf(data = st_as_sf(nc.borders), aes(geometry=geometry), 
               colour = "grey", linewidth=.3, fill = NA) +
  scale_fill_whitebox_c(
    palette = "deep",
    labels = scales::label_number(suffix = ""),
    na.value=NA
  ) +
  labs(
    fill = "",
    title = "North Carolina urban mask"
  ) +
  annotation_scale(
    location="bl", pad_x = unit(1, "cm"), 
		pad_y = unit(1, "cm"), 
		height = unit(0.30, "cm"), 
		text_cex = 1
	) +
	annotation_north_arrow(
	  location = "br", 
	  which_north = "true", 
		pad_x = unit(0.2, "cm"), 
		pad_y = unit(0.2, "cm")
	) +
	theme(
			axis.text = element_text(size=12, family="serif"),
			plot.caption = element_text(size=10, family="serif"),
			legend.position = "none",
			panel.background = element_rect(fill = "white"),
			panel.grid.major=element_line(colour="grey")
		)
```

Urban grid (200m-resolution)

```{r}
urb.pol <- as.polygons(urb.mask)
urb.rast <- rast(urb.pol, resolution = c(200, 200), crs = crs.meters)
urb.grid <- as.polygons(urb.rast)
urb.grid <- terra::intersect(urb.grid, urb.pol)
```

Rural grid (1km-resolution)

```{r}
rur.pol <- as.polygons(rur.mask)
rur.rast <- rast(rur.pol, resolution = c(1000, 1000), crs = crs.meters)
rur.grid <- as.polygons(rur.rast)
rur.grid <- terra::intersect(rur.grid, rur.pol)
```

### Map and save empty prediction grid

```{r}
m <- ggplot() +
  geom_spatvector(data = urb.grid, color='orange', size=.1) +
  geom_spatvector(data = rur.grid, color='green', size=.1) +
  geom_sf(data = st_as_sf(nc.borders), aes(geometry=geometry), 
               colour = "grey", linewidth=.3, fill = NA) +
  labs(
    fill = "",
    title = "Prediction grid"
  ) +
  annotation_scale(
    location="bl", pad_x = unit(1, "cm"), 
		pad_y = unit(1, "cm"), 
		height = unit(0.30, "cm"), 
		text_cex = 1
	) +
	annotation_north_arrow(
	  location = "br", 
	  which_north = "true", 
		pad_x = unit(0.2, "cm"), 
		pad_y = unit(0.2, "cm")
	) +
	theme(
			axis.text = element_text(size=12, family="serif"),
			plot.caption = element_text(size=10, family="serif"),
			legend.text = element_text(size=12, family="serif"),
			legend.title = element_text(size=12, family="serif"),
			panel.background = element_rect(fill = "white"),
			panel.grid.major=element_line(colour="grey")
		)
m
```

Save urban and rural grid (squared polygons) and save all prediction grid as a unique dataframe (centroids of raster's polygons, coordinates in wgs84)

```{r}
urb.grid.df <- centroids(urb.grid, inside=T)
rur.grid.df <- centroids(rur.grid, inside=T)
grid.points <- rbind(urb.grid.df, rur.grid.df)
grid.points <- project(grid.points, crs.meters)
writeVector(grid.points, "../input/prediction_grid_points_urb_rur_empty.shp")
```

## Spatial covariates addition

Interesting: with the terra::extract function, possibility to chose method='bilinear' to return a value interpolated from the values of the four nearest raster cells.

```{r}
grid.points <- vect("../input/prediction_grid_points_urb_rur_empty.shp")
```

Create entent for RTP area if we want to plot a zoom

```{r}
lat <- c(35.6, 36.11, 36.11, 35.6)
lon <- c(-79.19, -79.10, -78.39, -78.39)
ext.rtp <- vect(cbind(lon, lat), type="points", crs="+proj=longlat +datum=WGS84")
ext.rtp <- project(ext.rtp, crs(nc.borders))
ext(ext.rtp)
```

### Imperviousness

```{r}
imp.extract <- terra::extract(imp, grid.points, ID=T) 
```

### Tree canopy cover

To extract tree canopy cover (tcc), we use the bilinear method: values are interpolated from the values of the four nearest raster cells.

```{r}
tcc <-  rast("../input/NC_tree-canopy-cover_2021.tif")
tcc <- project(tcc, crs.meters)
tcc.extract <- terra::extract(tcc, grid.points, fun='mean', method='bilinear') 
tcc.extract.raw <- terra::extract(tcc, grid.points) 
```

### Building footprint

Important: it sounds like there are missing tiles in the data. An explanation can be found in the paper Heris, M.P., Foks, N., Bagstad, K., and Troy, A., 2020, A national dataset of rasterized building footprints for the U.S.: U.S. Geological Survey data release, <https://doi.org/10.5066/P9J2Y1WG.>:

"*We also identified systematic gaps in the Microsoft data for some geographic areas. These larger gaps seem to have a tile pattern, where aerial photos may have been unavailable to the Microsoft building detection algorithm"*

Their computational algorithm is applied to Microsoft released a U.S.-wide vector building dataset provided in 2018 but this dataset has missing tiles.

```{r}
build.fp <-  rast("../input/NC_building-footprints/NorthCarolina_sum.tif")
build.fp <- project(build.fp, crs.meters)
build.fp.extract <- terra::extract(build.fp, grid.points, fun='mean', method='bilinear') 
```

### Building height

```{r}
build.h <-  vect("../input/NC_building-height-by-block/NC_building-heights-by-block.shp")
build.h <- project(build.h, crs.meters)
build.h.extract <- terra::extract(build.h, grid.points) 
head(build.h.extract)
```

### Digital Elevation Model

```{r}
dem <- rast("../input/NC-DEM.tif")
dem <- project(dem, crs.meters)
dem.extract <- terra::extract(dem, grid.points, ID=T) 
head(dem.extract)
```

Merge all in grid.points vector

```{r}
cov.df <- cbind(dem.extract$Layer_1, imp.extract$NC_imperviousness_2019, tcc.extract$`NC_tree-canopy-cover_2021`, build.fp.extract$NorthCarolina_sum, build.h.extract$Height_cat)
colnames(cov.df) <- c("dem", "imp", "tcc", "build.fp", "build.h")
values(grid.points) <- as.data.frame(cov.df)
head(grid.points)
writeVector(grid.points, "../input/prediction_grid_points_urb_rur_spatialcov.shp")
```

## Meteorological covariates addition

The prediction grid will be stored as a dataframe (or datatable) with columns:

-   lat, lon, date

-   TN, TX (varies in space and time)

-   dem, imp, tcc, build.fp, build.h (varies in space)

It will have 56.794.820 rows (617335 pixels and 92 days) and 10 columns.

```{r}
grid.points <- vect("../input/prediction_grid_points_urb_rur_spatialcov.shp")
dim(grid.points)
era5.jja.vector.TN <- rast('../input/era5_daily_reanalysis_20220601_20220831_TN.tif')
era5.jja.vector.TX <- rast('../input/era5_daily_reanalysis_20220601_20220831_TX.tif')
```

Project ERA5 data in correct crs and extract ERA5 TN and TX at grid.points coordinates

```{r}
era5.jja.vector.TN <- project(era5.jja.vector.TN, crs.meters)
era5.jja.vector.TN.extract <- terra::extract(era5.jja.vector.TN, grid.points) 
era5.jja.vector.TX <- project(era5.jja.vector.TX, crs.meters)
era5.jja.vector.TX.extract <- terra::extract(era5.jja.vector.TX, grid.points) 
```

Create the final prediction grid dataframe and save it in a .csv

```{r}
df.TN <- melt(era5.jja.vector.TN.extract, id.vars = 'ID', variable.name = 'date', value.name='TN')
df.TX <- melt(era5.jja.vector.TX.extract, id.vars = 'ID', variable.name = 'date', value.name='TX')
df <- merge(df.TN, df.TX, by=c('ID', 'date'))

grid.points.df <- as.data.frame(grid.points)
grid.points.df$ID <- index(grid.points.df)
df <- merge(df, grid.points.df, by='ID')
head(df)
fwrite(df, '../input/prediction_grid_points_urb_rur_space_time_covariates_jja2022.csv')
```

### Session info

```{r}
sessionInfo()
```
